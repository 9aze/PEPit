import cvxpy as cp

from PEPit.pep import PEP
from PEPit.Function_classes.convex_function import ConvexFunction
from PEPit.Primitive_steps.bregmanproximal_step import BregmanProximal_Step


def wc_bpp(gamma, n):
    """
    In this example, we use a Bregman proximal point method (with kernel h)
    for solving the constrained smooth strongly convex minimization problem
        min_x { F(x) = f_1(x) + f_2(x) }
    for notational convenience we denote xs=argmin_x F(x);
    where f_1(x) and f_2(x) are closed convex proper functions.

    We show how to compute the worst-case value of F(xN)-F(xs) when xN is
    obtained by doing N steps of the method starting with an initial
    iterate satisfying Dh(x*,x0)<=1. (Dh is the Bregman distance generated by
    h, between x* and x0)

    [1] Radu-Alexandru Dragomir, Adrien B. Taylor, Alexandre d’Aspremont, and
         Jérôme Bolte. "Optimal Complexity and Certification of Bregman
         First-Order Methods". (2019)


    :param gamma: (float) step size.
    :param n: (int) number of iterations.
    :return:
    """

    # Instantiate PEP
    problem = PEP()

    # Declare a convex lipschitz function
    func1 = problem.declare_function(ConvexFunction,
                                    {})
    func2 = problem.declare_function(ConvexFunction,
                                     {})
    h = problem.declare_function(ConvexFunction,
                                     {})
    func = func1 + func2

    # Start by defining its unique optimal point and its function value
    xs = func.optimal_point()
    fs = func.value(xs)
    ghs, hs = h.oracle(xs)

    # Then Define the starting point of the algorithm
    x0 = problem.set_initial_point()
    gh0, h0 = h.oracle(x0)

    # Set the initial constraint that is the distance between x0 and x^*
    problem.set_initial_condition(hs - h0 - gh0 * (xs - x0) <= 1)

    # Compute trajectory starting from x0
    gh = gh0
    for i in range(n):
        x, _, _, _, _ = BregmanProximal_Step(gh, h, func, gamma)
        _, ff = func.oracle(x)
        gh, _ = h.oracle(x)

    # Set the performance metric to the final distance to optimum
    problem.set_performance_metric(ff - fs)

    # Solve the PEP
    wc = problem.solve(solver=cp.MOSEK)

    # Theoretical guarantee (for comparison)
    theory = 1/gamma/n
    print('*** Example file: worst-case performance of the Bregman Proximal Point in function values ***')
    print('\tPEP-it guarantee:\tf(y_n) - f_* <= ', wc)
    print('\tTheoretical guarantee on quadratics = 1 :\tf(y_n) - f_* <=  <= ', theory)
    # Return the worst-case guarantee of the evaluated method (and the upper theoretical value)

    # Return the rate of the evaluated method
    return wc


if __name__ == "__main__":

    gamma = 3
    n = 5

    rate = wc_bpp(gamma=gamma,
                   n=n)